\documentclass[10pt,a4paper]{article}

\usepackage{indentfirst}
%\usepackage{arev}
\usepackage{amsthm,amsfonts,amsmath,amssymb}
\usepackage[brazilian]{babel}
\usepackage[T1]{fontenc}
%\usepackage[latin1]{inputenc}
\usepackage[utf8]{inputenc}
%\usepackage{multicol}
\usepackage{setspace}
%\usepackage{natbib}
\usepackage[usenames,dvipsnames]{xcolor} 
\usepackage{pgf,tikz}
%\usepackage{algpseudocode}
\usepackage{float}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{wrapfig}
%\usepackage{listings}
%\usepackage[linesnumbered, ruled, portuguese]{algorithm2e}
\usepackage{multirow}
%\usepackage{verbatim}
%\usepackage[active,tightpage]{preview}
%\PreviewEnvironment{tikzpicture}
%\setlength\PreviewBorder{5pt}
\usepackage{geometry}
\usepackage[pdftex]{hyperref}
\usepackage{listings}
\usepackage[normalem]{ulem}
\lstdefinelanguage{VHDL}{
  morekeywords=[1]{
abs,access,after,alias,all,and,architecture,array,assert,attribute,begin,block,body,buffer,bus,case
component,configuration,constant,disconnect,downto,else,elsif,end,entity,exit,file,for,function,generate,
generic,group,guarded,if,impure,in,inertial,inout,is,label,library,linkage,literal,loop,map,mod,
nand,new,next,nor,not,null,of,on,open,or,others,out,package,port,postponed,procedure,process,pure,
range,record,register,reject,return,rol,ror,select,severity,signal,shared,sla,sli,sra,srl,subtype,then,
to,transport,type,unaffected,units,until,use,variable,wait,when,while,with,xnor,xor,
ABS,ACCESS,AFTER,ALIAS,ALL,AND,ARCHITECTURE,ARRAY,ASSERT,ATTRIBUTE,BEGIN,BLOCK,BODY,BUFFER,BUS,CASE
COMPONENT,CONFIGURATION,CONSTANT,DISCONNECT,DOWNTO,ELSE,ELSIF,END,ENTITY,EXIT,FILE,FOR,FUNCTION,GENERATE,
GENERIC,GROUP,GUARDED,IF,IMPURE,IN,INERTIAL,INOUT,IS,LABEL,LIBRARY,LINKAGE,LITERAL,LOOP,MAP,MOD,
NAND,NEW,NEXT,NOR,NOT,NULL,OF,ON,OPEN,OR,OTHERS,OUT,PACKAGE,PORT,POSTPONED,PROCEDURE,PROCESS,PURE,
RANGE,RECORD,REGISTER,REJECT,RETURN,ROL,ROR,SELECT,SEVERITY,SIGNAL,SHARED,SLA,SLI,SRA,SRL,SUBTYPE,THEN,
TO,TRANSPORT,TYPE,UNAFFECTED,UNITS,UNTIL,USE,VARIABLE,WAIT,WHEN,WHILE,WITH,XNOR,XOR
  },
  morekeywords=[2]{
    STD_LOGIC_VECTOR,STD_LOGIC,IEEE,STD_LOGIC_1164,
    NUMERIC_STD,STD_LOGIC_ARITH,STD_LOGIC_UNSIGNED,std_logic_vector,
    std_logic
  },
  morecomment=[l]{--}
}

\colorlet{keyword}{blue!100!black!80}
\colorlet{STD}{Lavender}
\colorlet{comment}{green!80!black!90}
\lstdefinestyle{vhdl}{
  language     = VHDL,
  basicstyle   = \footnotesize \ttfamily,
  keywordstyle = [1]\color{keyword}\bfseries,
  keywordstyle = [2]\color{STD}\bfseries,
  commentstyle = \color{comment},
  breaklines=true,                % sets automatic line breaking
  tabsize=3                                % sets default tabsize to 2 spaces
}

\geometry{a4paper,inner=2.0cm,outer=2.0cm,top=2.0cm,bottom=2.0cm}


\newcommand{\pr}{\hspace*{0.6cm}}
\newcommand{\vesp}{\vspace*{.3cm}}

\newcommand{\sen}{\mbox{\,sen}}
\newcommand{\cotg}{\mbox{\,cotg\,}}
\newcommand{\tg}{\mbox{\,tg\,}}
\newcommand{\cose}{\mbox{\,cos\,}}
\newcommand{\expo}{\mbox{\,e\,}}
\newcommand{\logg}{\mbox{\,log}}
\newcommand{\Sum}{\displaystyle\sum}
\newcommand{\Prod}{\displaystyle\prod}
\newcommand{\Int}{\displaystyle\int}
\newcommand{\dint}{\, \mathrm{d}}
\newcommand{\Lim}{\displaystyle \lim}
\newcommand{\Frac}{\displaystyle\frac}

\newcommand{\Nc}{N_{cont}}
\newcommand{\Ni}{N_{int}}
\newcommand{\Ne}{N_{estrela}}

\newcommand{\Dparc}[2]{\dfrac{\partial #1}{\partial #2}}
\newcommand{\Dparcn}[3]{\dfrac{\partial^#3 #1}{\partial^#3 #2}}

\newcommand{\R}{\mathbb{R}}
\newcommand{\V}{\mathcal{V}}
\newcommand{\I}{I_u}
\newcommand{\Fi}{\varphi}
\newcommand{\se}{\mbox{ se }}
\newcommand{\norma}[1]{\left|\left| #1 \right|\right|}
\newcommand{\sistema}[1]{ \left\{ #1 \right. }

\newtheorem{exemplo}{\pr \sc Exemplo}[section]%[chapter]
\newtheorem{defi}{\pr \sc Defini\c{c}\~ao}[section]%[chapter]
\newtheorem{obs}{\pr \sc Observa\cao}[section]%[chapter]
\newtheorem{teor}{\pr \sc Teorema}[section]%[chapter]
\newtheorem{lema}{\pr \sc Lema}[section]%[chapter]
\newtheorem{prop}{\pr \sc Proposi\cao}[section]%[chapter]
\newtheorem{exercise}{\pr \sc Exerc\'\i cios}[section]%[chapter]
\newtheorem{alg}{\pr Algoritmo}[section]%[chapter]

\setlength{\columnsep}{1cm}

\setlength{\columnsep}{1cm}

\lstset{language=VHDL}

\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  xleftmargin=\parindent,
  language=C,
  showstringspaces=false,
    keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{blue},
  stringstyle=\color{orange},
} 

%basicstyle=\footnotesize\ttfamily,

\lstset{escapechar=@,style=vhdl}

\begin{document}

\thispagestyle{empty}
\begin{center}
	UNIVERSIDADE DE SÃO PAULO – USP
	
	INSTITUTO DE CIÊNCIAS MATEMÁTICAS E DE COMPUTAÇÃO
	
	
	
	\vspace{7cm}
	
	\Large{\textbf{RELATÓRIO 1}}
	 
	\Large{\textbf{SME 104 – CÁLCULO NUMÉRICO}}
	
	\vspace{6cm}
	
	Alunos: Adams Vietro Codignotto da Silva - $6791943$ \\ Ana Clara Kandratavicius Ferreira - $7276877$
	
	\vspace{6cm}
	
	São Carlos
	
	2014
\end{center}

\newpage

\pagenumbering{arabic}
\section*{Introdução}
    Em Cálculo Numérico utilizamos métodos iterativos para resolver sistemas lineares de grande porte. Um desses métodos é o de Gauss-Seidel, que é derivado do método de Jacobi, porém com uma velocidade de convergência maior. Neste trabalho, estaremos implementando o método Gauss-Seidel, que nos garante a convergência independentemente da aproximação inicial $x^{(0)}$ atribuída.
\section*{Modelagem do problema}
    Assumimos que as matrizes de entradas satisfaçam a condição de que:
\begin{itemize}
\item A matriz A seja \textbf{diagonal estritamente dominante por linhas ou colunas}
\end{itemize}
e portanto, não foi feita a verificação da mesma.
    
    Partindo do método iterativo de Gauss-Seidel para resolver o sistema linear Ax=b, como visto em aula:
\begin{equation}
\nonumber
x_i^{(k+1)}=(D-L)^{-1}(Ux^{(k)}+b)
\end{equation}
onde x é o vetor de iteração, D é a matriz diagonal de A, L e U são as matrizes da decomposição LU de A e b é a matriz solução do sistema, podemos reescrever fórmula como:
\begin{equation}
\nonumber
x_i^{(k+1)}=\dfrac{b_i-\underset{j=1}{\overset{i-1}\sum}a_{ij}x_j^{(k+1)} - \underset{j=i+1}{\overset{n}\sum}a_{ij}x_j^{(k)}}{a_{ii}}
\end{equation}
\subsection*{Prova da Convergência}
    Ainda podemos provar que o método iterativo converge, qualquer que seja a aproximação inicial $x^{(0)}$:

    Se $\rho(C)<1$, onde $C = -(L+D)^{-1}U$, tomando $\epsilon=1-\rho(C)>0$, sabemos que existe uma norma $\| . \|$ tal que $\| C\| < \rho(C) + \epsilon=1$.

    Resta ver que $\rho(C)<1$ é condição necessária.

    Supondo que exista um valor próprio \textit{z} tal que |z|$\geq 1$, então se $x^{(0)}=x-v$, onde x é a solução e v o vetor próprio associado a z, obtemos $e^{(k)}=C^k e^{(0)}=C^kv=z^kv$, e como v está fixo e $|z|^k\geq 1$, então $e^{(k)}$ não tende a zero, não havendo convergência para o $x^{(0)}$ definido.

\section*{Experimentos e Resultados}
    O trabalho foi implementado utilizando o software Matlab R2013a, e realizamos os seguintes testes:
\begin{itemize}
\item Dado um sistema linear Ax=b, para uma matriz A pentadiagonal da forma
\begin{equation}
\tag{1}
\begin{cases}
    \begin{array}{ll}
        a_{i,i}=4 & i=1,2,\cdots, n \\
        a_{i,i+1}=a_{i+1,i}=-1 & i=1,2,\cdots,n-1 \\
        a_{i,i+3}=a_{i+3,i}=-1 & i=1,2,\cdots,n-3 \\
        a_{i,j}=0& \mbox{para o restante}
    \end{array}
\end{cases}
\label{matrizA}
\end{equation}
e o termo independente b da forma
\begin{equation}
\nonumber
b_i=\underset{j=1}{\overset{n}\sum}a_{ij}, \mbox{ para }i=1,\cdots,n
\end{equation}
$\quad$ Utilizamos como parâmetros n=50 e n=100, erro máximo como $10^{-6}$ e um limite de 1500 iterações para resolver o sistema. Em ambos os casos, partimos da aproximação inicial $x^{(0)}=0$. Para o caso n=50, após 557 iterações, obtivemos um vetor x com um resultado muito próximo ao esperado (onde $x_i =1$, para i=1,...,n).

$\quad$ Porém, para o caso n=100, 1500 iterações não foram suficientes para a convergência do método, sendo necessárias 1846 iterações para que houvesse a convergência utilizando o mesmo fator de erro. O resultado obtido para n=100 e 1846 iterações está próximo ao esperado como aconteceu com n=50.

\item     Utilizando uma matriz A definida pela equação \eqref{matrizA} e um vetor b onde:
\begin{equation}
\nonumber
\begin{array}{ll}
b_i=\dfrac{1.0}{i} & i=1,2,\cdots,n
\end{array}
\end{equation}
para n=40, com erro de $10^{-6}$ e um limite de 1500 iterações, partindo da aproximação inicial $x^{(0)}=0$, obtemos a convergência dentro de 389 iterações.

$\quad$ Para mostrar que a solução obtida é aceitável, fez-se a seguinte comparação: tomando $\overline{B}=A\overline{x}$ em que $\overline{x}$ é a solução numérica obtida, podemos calcular $\| \overline{B} - B\|_{\infty}$ em que $B = Ax$ sendo $x$ a solução exata do sistema. O resultado é $1.9687\times 10^{-6}$, um erro baixo, ou seja, uma boa aproximação da solução exata do sistema.
\end{itemize}
\section*{Conclusões}
    O método de Gauss-Seidel é excelente para aproximar a convergência da solução de sistemas lineares, além de ser fácil de ser implementado. Porém, a velocidade de convergência ainda é muito lenta para que o método seja usado na prática, levando $O(e n^2)$ iterações para reduzir o erro por um fator de $10^e$ de um sistema linear $(n\times n)$ com matrizes de diagonais estritamente dominantes.

    Se utilizarmos a fórmula geral $x^{(k+1)}=(D-L)^{-1}(Ux^{(k)}+b)$, apesar de ser de ainda mais fácil implementação, nos leva a algumas condições necessárias, como a matriz D nem sempre poder ser invertível, e $(D^{-1}L)$ deve ter raio espectral menor que 1. Se o raio espectral for maior que 1, as iterações podem nos levar a um limite infinito.
	
	\newpage
	\section*{Implementação do método Gauss-Seidel Iterativo}
	\begin{verbatim}
function C = GaussSeidel(A,B,n,EPS,ITMAX)
X=zeros(n,1);
iteracoes=0;
erro=1000;

    while erro>EPS && iteracoes<ITMAX
       XOld=X; %X_j = X_i
       for i=1:n %percorrendo todos os x_i's
        T=Soma1(A,X,i); %somatório de j=1 a i-1 de a_ij x_j^{k+1}
        U=Soma2(A,XOld,i,n); %somatório de j=i+1 a n de a_ij x_j^{k}
        X(i)=(B(i)- T - U)/A(i,i);
       end
       erro=NormaInfinita(XOld,X,n); %calcula erro da iteração
       iteracoes=iteracoes+1;
    end

    if iteracoes==ITMAX  %caso chegou ao limite de iterações, divergiu
        fprintf('DIVERGE!\n');
    else 
        fprintf('\nQuantidade de Iterações:\n');
        disp(iteracoes);
        fprintf('Converge para:\n');
        C=X
    end
end

function [soma1] = Soma1(A,x_0,i) %calcula primeiro somatório do método
soma1=0;
    for j=1:i-1
        soma1 = soma1 + (A(i,j)*x_0(j));
    end
end

function [soma2] = Soma2(A,x_0,i,n)  %calcula segundo somatório do método
soma2=0;
    for j=i+1:n
        soma2 = soma2 + (A(i,j)*x_0(j));
    end
end

function [max] = NormaInfinita(xk,xk1,n) %calcula norma infinita dados 
                                         %dois vetores xk e xk1, de tamanho n

    x=xk1-xk;
    max=0;
    for i=1:n
            soma=abs(x(i,1));
        if(soma>max)
            max=soma;
        end
    end
end
\end{verbatim}
\newpage
	\subsection*{Funções Auxiliares}
	\subsubsection*{Criar matriz pentadiagonal}
	\begin{verbatim}
function [m] = Pentadiagonal(n) %n é tamanho da matriz
    [m]=zeros(n);
    for i=1:n
        m(i,i)=4;
    end

    for i=1:n-1
        m(i,i+1)=-1;
        m(i+1,i)=-1;
    end

    for i=1:n-3
        m(i,i+3)=-1;
        m(i+3,i)=-1;
    end
end
\end{verbatim}
\subsubsection*{Criar Vetor B (teste 1)}
\begin{verbatim}
function [b] = VetorB(A, n)
    b=zeros(n,1);
    for i=1:n
        for j=1:n
        b(i,1)=b(i,1) + A(i,j);
        end
    end
end
\end{verbatim}
\subsubsection*{Criar Vetor B (teste 2)}
\begin{verbatim}
function [B] = VetorB2(n)
    B=zeros(n,1);
    for i=1:n
        B(i,1) = 1.0/i;
    end
    
\end{verbatim}
\end{document}